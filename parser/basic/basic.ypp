%{
// --------------------------------------------------------------------------------
// MIT License
//
// Copyright (c) 2018 Jens Kallup
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// --------------------------------------------------------------------------------
#include <pthread.h>

#include <stdio.h>
#include <strings.h>
#include <stdlib.h>

#include <QString>

#include "source/includes/dbase/mainwindow.h"
#include "source/parser/common.h"

#undef  yyparse
#undef  yylex

#undef  yychar
#undef  yynerrs
#undef  yylval
#undef  yyerror
#undef  yyset_in
#undef  yytext

#define yychar    basicchar
#define yynerrs   basicnerrs
#define yylval    basiclval
#define yyerror   basicerror
#define yyrestart basicrestart
#define yyset_in  basicset_in
#define yytext    basictext;

#define yylex     basiclex
#define yyparse   basicparse

extern void basicset_in (FILE *);
extern void basicrestart(FILE *);

extern int  basiclex();
extern int  basicparse();
extern int  basicerror(const char*);

extern QString basic_text;

# include <QString>
# include <QMessageBox>
# include <QString>
# include <QFile>
# include <QTextStream>

# include "source/includes/dbase/mainwindow.h"
# include "source/parser/basic/basic.h"

struct BasicThreadInfo * basicThread = nullptr;

int basicerror(const char *p) {
    throw QString("Error at line: %1: %2. ")
    .arg(basicThread->thread_lineno + 1)
    .arg(p);
    return basicThread->thread_lineno;
}

// ----------------------------------
// make basic parser thread safe ...
// ----------------------------------
static void *
BasicThreadStart(struct BasicThreadInfo * arg)
{
    struct BasicThreadInfo * basicThread = arg;
    int file_length = 0 ;
    
    QString filename;
    basicThread->thread_lineno = 1;
    basicThread->thread_code.clear();
    
    if (basicThread->thread_file.length() < 1)
    throw QString("no parser file given - string empty");
    
    if (!basicThread->thread_file.endsWith(".bas"))
         basicThread->thread_file.append(".bas"); filename =
         basicThread->thread_file;

    QFileInfo f(filename);
    QString file_path  = f.absolutePath();
    QString input_str  = file_path;
    QString output_str = file_path;
    
    input_str .append(QString("/%1").arg(f.fileName()));
    output_str.append(QString("/%1").arg(f.fileName()));

    // todo
    output_str.chop(3);
    output_str.append("forth");


    //
    basicThread->thread_input = fopen(input_str.toLatin1().data(),"r");
    
    fseek(basicThread->thread_input,0,SEEK_END); file_length =
    ftell(basicThread->thread_input );
    fseek(basicThread->thread_input,0,SEEK_SET);
    
    basicset_in (basicThread->thread_input);
    basicrestart(basicThread->thread_input);

    basicThread->thread_window->ui->progressBar->setMaximum(file_length);
    basicThread->thread_window->ui->progressBar->setValue(0);
    
    basicparse();

    // generate output
    QFile out_file2(output_str);
    if  (!out_file2.open(
        QIODevice::WriteOnly  |
        QIODevice::Text)) throw
        QString("forth data file could not save.");
    
    QTextStream out2(&out_file2);
    out2 << "\\ BASIC -> Forth Compiler by paule32\n"
         << "\\ DO NOT EDIT THIS FILE - ALL DATA WILL BE LOST.\n"
         << "\\ 2018 - KALLUP * non-profit Software\n"
         << basicThread->thread_code
        
         << "\nbye\n";
        
    out_file2.close();
    fclose(basicThread->thread_input);
    
    return (char*)"SUCCESS";
}

%}

//-- SYMBOL SEMANTIC VALUES -----------------------------
%union {
  int val; 
  char sym;
};

%token _PRINT_ _NAME_ _ASSIGN_ _PEQUAL_ _STRING_
%token _NUMBER_ _ASSERT_ _EQUAL_

%start basic_program

//-- GRAMMAR RULES ---------------------------------------
%%

basic_program:
      basic_print
    | basic_program basic_program
    ;

basic_print:
    { /* empty */ }
    | _PRINT_ _STRING_ {
        basic_text.chop(1);
        basicThread->thread_code.append( QString(".%1\\n\"\n").arg(
        
        basicThread->thread_forthstack.first().content.toString()));
        basicThread->thread_forthstack.pop_front();
    }
    | _ASSERT_ '(' _NUMBER_ _EQUAL_ _NUMBER_ ')' {
        
        QString b2 =
        basicThread->thread_forthstack.first().content.toString();
        basicThread->thread_forthstack.pop_front();
        
        QString b1 =
        basicThread->thread_forthstack.first().content.toString();
        basicThread->thread_forthstack.pop_front();
        
        qDebug() << b1;
        qDebug() << b2;
        
        basicThread->thread_code.append(QString("T{ #%1 -> #%2 }T\n")
        .arg(b1)
        .arg(b2));
    }
    ;
%%

//-- FUNCTION DEFINITIONS ---------------------------------

int basicmain(MainWindow *w, QString file)
{
    pthread_attr_t attr;
    int stack_size = 100000;
    void * res;
    int s;
        
    try {
        // thread ...
        if ((s = pthread_attr_init(&attr)) != 0)
        throw std::string("pthread_attr_init");
        
        if ((s = pthread_attr_setstacksize(&attr, stack_size)) != 0)
        throw std::string("pthread_attr_stacksize");
        
        basicThread = new BasicThreadInfo;
        basicThread->thread_num    = 0;
        basicThread->thread_stacks = stack_size;
        basicThread->thread_file   = file;
        basicThread->thread_window = w;
        
        if ((s = pthread_create(
        &basicThread->thread_id,
        &attr,BasicThreadStart ,basicThread)) != 0)
        throw std::string("pthread_create");
        
        if ((s = pthread_attr_destroy(&attr)) != 0)
        throw std::string("pthread_attr_destory");
        
        if ((s = pthread_join(basicThread[0].thread_id,&res)) != 0)
        throw std::string("pthread_join");
        
        if (!strcmp(reinterpret_cast<char*>(res), "FAIL"))
        throw QString(
        "BASIC parser FAIL\n"
        "Compiling BASIC to Forth  FAIL.");
        
        if (!strcmp(reinterpret_cast<char*>(res), "SUCCESS"))
        QMessageBox::information(w,
        "BASIC parser OK\n",
        "Compiling BASIC to Forth SUCCESS.");
    }
    catch (QString e) {
        QMessageBox::warning(w,
        "Execption occur",e);
    }
    catch (std::string e) {
        QMessageBox::warning(w,
        "Execption occur",e.c_str());
    }

    delete basicThread;
    return 0;
}
